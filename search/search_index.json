{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Maquette de labo \"Pendule de Furuta\"","text":"<p>Le pendule de Furuta est un pendule invers\u00e9 rotatif, invent\u00e9 par Katsuhisa Furuta en 1992 au \"Tokyo Institute of Technology\". Il s'agit d'un syst\u00e8me instable en mode invers\u00e9 (Up), fortement nonlin\u00e9aire et sous-actionn\u00e9 (deux degr\u00e9s de libert\u00e9, mais un seul actionneur). De nombreux laboratoires automatiques disposent de pendules de Furuta, pour l'enseignement et pour la recherche. A la HEIG-VD, lors d'un  travail de Bachelor, un prototype d'un pendule de Furuta a \u00e9t\u00e9 r\u00e9alis\u00e9 en 2024, dans le but de l'affiner par la suite, de le dupliquer et de l'utiliser finalement comme nouvelle maquette de laboratoire.</p>"},{"location":"#avantages-du-pendule-de-furuta","title":"Avantages du pendule de Furuta","text":"<ul> <li>Contrairement au pendule inverse classique qui n\u00e9cessite un rail et qui est encombrant et cher, le pendule de Furuta est tr\u00e8s compact et relativement bon march\u00e9.</li> <li>Avec ses deux positions d'\u00e9quilibre \"Up\" et \"Down\", le pendule de Furuta offre de nombreuses possibilit\u00e9s pour cr\u00e9er des manipulations de laboratoire de complexit\u00e9 diff\u00e9rente. </li> </ul> <p>Ci-dessous une liste de possibilit\u00e9s pour des futurs laboratoires, TB, TM et d\u00e9monstrateurs pour des salons d'exposition :</p> <ul> <li>labo <code>Regul</code>, 4\u00e8me semestre : uniquement r\u00e9gler le moteur en position par un r\u00e9gulateur PID; ne pas prendre compte le pendule en mode \"Down\" qui perturbe un peu.</li> <li>labo <code>RegNum</code>, 5\u00e8me semestre : ajouter au PID  un preshaping filter pour filtrer la consigne de position du moteur, afin de ne pas exciter la fr\u00e9quence de r\u00e9sonance du pendule. Le pendule devrait s'arr\u00eater de bouger sans oscillations r\u00e9siduelles apr\u00e8s une consigne de mouvement de A \u00e0 B.</li> <li>labo <code>AAV</code>, cours \u00e0 choix au semestre 6 : retour d'\u00e9tat par placement de p\u00f4les ou par LQR pour les modes \"Up\" et \"Down\". Le mod\u00e8le simplifi\u00e9 dans l'espace d'\u00e9tat est d'ordre 4, donc 4 param\u00e8tres dans le retour d'\u00e9tat.</li> <li>futurs <code>TB</code> et <code>TM</code>, tester diff\u00e9rents strat\u00e9gies pour le <code>Swing Up</code>, \u00e9vtl. tester l'utilisation de l'intelligence artificielle (IA) comme solution alternative.</li> <li><code>d\u00e9monstrateur</code> pour salons d'exposition. Disposant dans le futur de ~14 maquettes de pendules de Furuta, on pourrait envisager une mise en sc\u00e8ne des maquettes qui font des mouvements coordonn\u00e9s de ballet. Cela n\u00e9cessiterait une communication entre les maquettes.</li> </ul>"},{"location":"#objectifs-et-contraintes","title":"Objectifs et contraintes","text":"<p>L'objectif \u00e9tait de d\u00e9velopper et produire une s\u00e9rie de pendules de Furuta destin\u00e9e surtout \u00e0 l'enseignement. Pour cela, on s'est mis les contraintes suivantes :</p> <ul> <li>Pas besoin de PC fixes, les \u00e9tudiants devraient pouvoir utiliser leurs propres PC portable.</li> <li>Pas besoin d'installer des logiciels ou des pilotes sur les PC portables des \u00e9tudiants.</li> <li>Pour les \u00e9tudiants, possibilit\u00e9 de pouvoir changer facilement le code de la r\u00e9gulation, sans cacher la r\u00e9gulation derri\u00e8re une interface graphique.</li> </ul>"},{"location":"conception/","title":"Conception","text":""},{"location":"conception/#mecanique","title":"M\u00e9canique","text":"<p>La m\u00e9canique est fortement inspir\u00e9e par Ben Katz qui a d\u00e9velopp\u00e9 et produit une s\u00e9rie de pendules de Furuta pour un laboratoire d'automatique. L'\u00e9l\u00e9ment principal de son design est un moteur BLDC \u00e0 rotor ext\u00e9rieur de l'entreprise T-Motor avec un trou au milieu. Un collecteur est fourni avec, qui se place exactement dans ce trou, et qui permet de transmettre les signaux du capteur angulaire du pendule depuis la partie rotative en haut vers la partie fixe en bas. Ceci permet d'\u00e9viter des c\u00e2bles qui limiteraient une rotation de plusieurs tours, ce qui est un atout majeur de notre maquette Furuta.</p> <p>Pour avoir un minimum de frottement et de jeu m\u00e9canique, des roulements c\u00e9ramiques ont \u00e9t\u00e9 utilis\u00e9s pour le pendule.</p>"},{"location":"conception/#capteurs","title":"Capteurs","text":"<p>Avec ses 2 degr\u00e9s de libert\u00e9, deux capteurs incr\u00e9mentaux ont \u00e9t\u00e9 utilis\u00e9s, un capteur Posic pour mesurer la position angulaire du moteur, et un capteur US Digital pour mesurer la position angulaire du pendule.</p>"},{"location":"conception/#electronique","title":"\u00c9lectronique","text":"<p>L'\u00e9lectronique est compos\u00e9e d'un sandwich de 3 PCB, sans aucun c\u00e2blage entre les PCB. En bas, une RPI5, au milieu un PCB d\u00e9velopp\u00e9 dans la maison. Ce PCB du milieu comporte un convertisseur DC/DC pour pouvoir alimenter la maquette avec un seul bloc d'alimentation de 24V. Le PCB au milieu comporte aussi une interface USB-UART (RS232) pour pouvoir param\u00e9trer le drive. Le PC en haut consiste d'un drive de la maison ELMO qui effectue uniquement la r\u00e9gulation de courant (couple) du moteur. </p>"},{"location":"drive_elmo/","title":"Param\u00e9trisation du drive ELMO","text":"<p>Note</p> <p>A Compl\u00e9ter</p> <p>Pour la param\u00e9trisation du drive ELMO, il faut pr\u00e9alablement installer le logiciel de param\u00e9trisation EASII. La communication avec le drive se fait via une liaison s\u00e9rielle (RS232). Pour cela, une puce <code>????</code> est inclue sur le PCB custom de la maquette qui fait passerelle USB &lt;=&gt; RS232. Lors de la premi\u00e8re connection USB, un pilote devrait s'installer.</p> <p>Configuration du baudrate ......</p> <p>La possibilit\u00e9 la plus simple pour param\u00e9trer un drive ELMO vierge consiste \u00e0 downloader le fichier de configuration <code>xxxxxx.yyy</code>. Pour ce faire, la marche \u00e0 suivre est la suivante :</p> <ul> <li>bla1</li> <li>bla2</li> <li>bla3</li> </ul> <p>Ci-dessous un r\u00e9sum\u00e9 des settings inclus dans le fichier de param\u00e9trisation :</p> <ul> <li>nombre de p\u00f4les de pairs = 7</li> <li>courant max</li> <li>vitesse max</li> <li>mode torque [UM = ?]</li> <li>configuration encodeur US-Digital  ....</li> <li>configuration Posic ....</li> <li>configuration de la commutation <code>Binary Search</code> ....</li> <li>protection bus DC  ...</li> <li>etc, etc,  ...</li> </ul> <p>Le r\u00e9gulateur de courant peut \u00eatre d\u00e9termin\u00e9 en mode \"auto-tuning\". Les param\u00e8tres du r\u00e9gulateur de courant trouv\u00e9 exp\u00e9rimentalement sont \u00e0 peu pr\u00e8s ....</p> <p>Un petit code embarqu\u00e9 sur le drive copie en permanence la vitesse du pendule FV[2] sur UI[1] qui est mapp\u00e9 en PDO.  .....  #@AUTOEXEC  ....</p>"},{"location":"network/","title":"Int\u00e9gration dans le r\u00e9seau HEIG-VD","text":"<p>Note</p> <p>A Compl\u00e9ter</p> <p>Les \u00e9tudiants doivent pouvoir se logger sur la maquette via SSH, id\u00e9alement sans fil. Au boot, chaque maquette doit faire un acc\u00e8s sur github et faire un \"auto-pull\". Nice to have: les maquettes doivent pouvoir communiquer entre elles pour r\u00e9aliser un d\u00e9monstrateur \"ballet\" avec des mouvements synchronis\u00e9s des 14 maquettes.</p>"},{"location":"regulation/","title":"R\u00e9gulation","text":""},{"location":"regulation/#architecture-de-regulation","title":"Architecture de r\u00e9gulation","text":"<ul> <li> <p>Le drive ELMO s'occupe de la commutation du moteur BLDC et de la r\u00e9gulation de courant, donc la r\u00e9gulation de couple. De surcroit, le drive ELMO interface les 2 capteurs incr\u00e9mentaux, et calcule les vitesses de rotation. Le calcul des vitesses c\u00f4t\u00e9 drive est moins bruit\u00e9e, car le jitter de la p\u00e9riode d'\u00e9chantillonnage est tr\u00e8s faible.</p> </li> <li> <p>La RPI5 communique avec le drive via CANopen, et lui communique la consigne de couple via des trames PDO. Le drive transmet au RPI5 les positions et vitesses des deux encodeurs incr\u00e9mentaux.</p> </li> </ul>"},{"location":"regulation/#logiciel-de-regulation","title":"Logiciel de r\u00e9gulation","text":"<p>La r\u00e9gulation du pendule s'effectue sur la RPI5 dans le langage de programmation Python. Ce choix a \u00e9t\u00e9 motiv\u00e9 par le fait que nos \u00e9tudiants ont plus d'exp\u00e9rience en Python que en C. Cela permet aussi une facilit\u00e9 de programmation.</p> <p>Evidemment Python ne permet pas d'atteindre le temps r\u00e9el dur, et le jitter de la p\u00e9riode d'\u00e9chantillonnage est relativement \u00e9lev\u00e9. Parfois, il y a m\u00eame des coups d'horloge rat\u00e9s. Ceci n'est pas trop grave, car la fr\u00e9quence d'\u00e9chantillonnage vaut 1 kHz, ce qui est tr\u00e8s \u00e9lev\u00e9 par rapport \u00e0 la dynamique de la maquette. Pour minimiser le probl\u00e8me du jitter, il faut imp\u00e9rativement lancer le programme de r\u00e9gulation en priorit\u00e9 maximale en utilisant la commande  <code>sudo chrt --fifo 99 xxxx.py</code>.</p> <p>L'horloge pour lancer p\u00e9riodiquement le code de la r\u00e9gulation provient du drive ELMO. La RPI5 configure \u00e0 l'initialisation des PDO CANopen sur le drive. Ces PDO sont \u00e0 une cadence de 1 ms. Le programme de r\u00e9gulation sur la RPI5 fait un polling et attend la r\u00e9ception de la trame CANopen. Il n'y a donc pas d'interruptions ou d'events, c'est simplement une boucle while qui attend l'arriv\u00e9e des trames.</p>"},{"location":"regulation/#modelisation-et-identification","title":"Mod\u00e9lisation et identification","text":"<p>La mod\u00e9lisation du pendule de Furuta est bas\u00e9e sur la publication [2], dans laquelle le formalisme de Lagrange est utilis\u00e9 pour trouver les \u00e9quations diff\u00e9rentielles nonlin\u00e9aires. Rien que l'expression de l'\u00e9nergie cin\u00e9tique n'est pas \u00e9vidente. Ensuite, une lin\u00e9arisation autour du point d'\u00e9quilibre \"Up\" ou \"Down\" est appliqu\u00e9e. Cette approche n'est pas \u00e0 la port\u00e9e de nos \u00e9tudiants Bachelor, car il leur manque les bases m\u00e9caniques et math\u00e9matiques. C'est pour cela que c'est pr\u00e9f\u00e9rable d'expliquer aux \u00e9tudiants la structure d'un mod\u00e8le lin\u00e9aire simplifi\u00e9.</p>"},{"location":"regulation/#modele-lineaire-simplifie","title":"Mod\u00e9le lin\u00e9aire simplifi\u00e9","text":"<p>Avec les hypoth\u00e8ses simplificatrices suivantes a) Frottement et jeu m\u00e9canique n\u00e9gligeable b) Dynamique du drive n\u00e9gligeable c) Couple \"cogging\" du moteur n\u00e9gligeable d) P\u00e9riode d'\u00e9chantillonnage n\u00e9gligeable e) Retards de transmission CANopen n\u00e9gligeables, on obtient un mod\u00e8le lin\u00e9aire simplifi\u00e9 en temps continu ayant la structure avec le sch\u00e9ma bloc suivant: </p> <p>Ici, \\(\\tau(t)\\) est le signal d'entr\u00e9e correspondant au couple appliqu\u00e9 au moteur, \\(\\theta_1(t)\\) est l'angle mesur\u00e9 du moteur et \\(\\theta_2(t)\\) est l'angle mesur\u00e9 du pendule. La structure des deux fonctions de transfert impliqu\u00e9es est la suivante : \\(\\(G_1(s) = \\frac{k_1 (s^2 - z^2)}{s^2(s^2 - p^2)}\\)\\)et \\(\\(G_2(s) = \\frac{k_2}{s^2 - p^2}\\)\\) ayant que quatre param\u00e8tres \\(k_1, k_2, z\\) et \\(p\\) \u00e0 identifier.</p> <p>En mode \"Down\", \\(p^2\\) et \\(z^2\\) sont n\u00e9gatifs ce qui donne lieu \u00e0 deux p\u00f4les \\(jp, -jp\\) et deux z\u00e9ros \\(jz, -jz\\) purement imaginaires. En mode \"Up\", \\(p^2\\) et \\(z^2\\) sont positifs ce qui donne lieu \u00e0 deux p\u00f4les \\(p, -p\\) et deux z\u00e9ros \\(z, -z\\) r\u00e9els, dispos\u00e9s symm\u00e9triquement par rapport \u00e0 l'origine. La figure ci-dessous r\u00e9sume la configuration p\u00f4les-z\u00e9ros de \\(G_1(s)\\) pour les deux modes. </p> <p>Le facteur \\(s^2\\) au d\u00e9nominateur de \\(G_1(s)\\) traduit un comportement double-int\u00e9grateur. Si l'on applique un couple constant, le moteur va essentiellement acc\u00e9l\u00e9rer. Le terme \\(\\frac{s^2-z^2}{s^2-p^2}\\) traduit le couple perturbateur exerc\u00e9 par le pendule sur le moteur. En mode \"Down\", \\(p\\) correspond \u00e0 une pulsation de r\u00e9sonance, et \\(z\\) correspond \u00e0 une pulsation d'anti-r\u00e9sonance.</p> <p>Le changement entre \"Down\" et \"Up\" se traduit simplement par un changement de signe de \\(p^2\\), \\(z^2\\) et \\(k_2\\). Avec cette observation, on peut faire l'identification des quatre param\u00e8tres en mode \"Down\", ce qui est beaucoup plus facile, car le syst\u00e8me \u00e0 r\u00e9gler est stable. Puis ensuite, pour le mod\u00e8le \"Up\", on peut simplement changer le signe des param\u00e8tres \\(p^2\\), \\(z^2\\) et \\(k_2\\).</p> <p>L'identification et la mesure du diagramme de Bode pr\u00e9sentent plusieurs difficult\u00e9s:</p> <ul> <li>le comportement quasi double-int\u00e9grateur est fortement passe-bas et masque les effets \u00e0 haute fr\u00e9quence,</li> <li>l'anti-r\u00e9sonance et la r\u00e9sonance sont assez rapproch\u00e9es, et il faudra une r\u00e9solution fr\u00e9quentielle \u00e9lev\u00e9e pour bien les visualiser,</li> <li>l'amortissement de l'anti-r\u00e9sonance et de la r\u00e9sonance est relativement faible, et le r\u00e9gime transitoire dure longtemps.</li> </ul> <p>C'est pour cette raison, une suite binaire pseudo-al\u00e9atoire comme signal d'excitation a \u00e9t\u00e9 \u00e9cart\u00e9e. Comme alternative, un signal purement sinuso\u00efdal est appliqu\u00e9 en mode \"Down\" sur le couple \\(\\tau(t)\\), sans pr\u00e9sence de r\u00e9gulateur. Ensuite,</p> <ul> <li>le r\u00e9gime harmonique \u00e9tabli est attendu,</li> <li>les signaux \\(\\theta_1(t)\\) et \\(\\theta_2(t)\\) sont mesur\u00e9s sur un nombre entier de p\u00e9riodes,</li> <li>ces signaux sont projet\u00e9s (produit scalaire) sur \\(e^{-j\\omega t}\\). Ceci correspont \u00e0 l'\u00e9valuation de la transform\u00e9e en \\(\\cal{Z}\\) \u00e0 une seule fr\u00e9quence, et donne lieu \u00e0 un nombre complexe</li> <li>le nombre complexe associ\u00e9 des sorties est divis\u00e9 par celui de l'entr\u00e9e</li> <li>la fr\u00e9quence est incr\u00e9ment\u00e9e.</li> </ul> <p>Cette mani\u00e8re de faire permet un contr\u00f4le pr\u00e9cis de la grille fr\u00e9quentielle et des amplitudes d'excitation. Apr\u00e8s, on peut comparer les diagrammes de Bode mesur\u00e9s avec les diagrammes de Bode du mod\u00e8le, et ajuster \"manuellement\" les quatre param\u00e8tres (et \u00e9vtl. les taux d'amortissement) jusqu'au point o\u00f9 les diagrammes de Bode mesur\u00e9s et simul\u00e9s collent \"au mieux\". L'effet des param\u00e8tres sur les diagrammes de Bode est \u00e9vident, et on n'a pas forc\u00e9ment besoin d'une m\u00e9thode d'optimisation.</p> <p>Le diagramme de Bode de \\(G_1(s)\\) p.ex. devrait ressembler au graphique ci-dessous. </p>"},{"location":"regulation/#outils-de-simulation-matlab","title":"Outils de simulation Matlab","text":"<p>Les outils suivants ont \u00e9t\u00e9 d\u00e9velopp\u00e9s :</p> <p><code>Modelling_Control_S.mlx</code> Il s'agit d'un Live script Matlab, dans lequel se trouve</p> <ul> <li>une estimation des param\u00e8tres physiques</li> <li>le calcul du mod\u00e8le lin\u00e9aris\u00e9 pour les deux points d'\u00e9quilibre \"Up\" et \"Down\".</li> <li>Le calcul du gain du retour d'\u00e9tat, soit avec placement de p\u00f4les ou bien par LQR.</li> <li>L'appel du fichier de Simulink qui contient un mod\u00e8le nonlin\u00e9aire avec mod\u00e9lisation de d\u00e9fauts</li> </ul> <p><code>LinPlant = CalcLinPlant(J0_hat, J2_hat, m2, L1, l2, g, Mode)</code> La fonction <code>CalcLinPlant.m</code> calcule le mod\u00e8le lin\u00e9aris\u00e9 dans l'espace d'\u00e9tat en fonction des param\u00e8tres physiques.</p> <p><code>Furuta_CL_Sim.slx</code> C'est un mod\u00e8le Simulink nonlin\u00e9aire affin\u00e9 de la boucle ferm\u00e9e, incluant l'effet de l'\u00e9chantillonnage, estimation de vitesse, etc.</p> <p><code>[zsq, psq, k1, k2] = PhysPar2RedPar(J0_hat, J2_hat, m2, L1, l2, g, Mode)</code> La fonction <code>PhysPar2RedPar.m</code> calcule \u00e0 partir des 6 param\u00e8tres physiques les 4 param\u00e8tres r\u00e9duits.</p> <p><code>LinPlant = RedPar2ss(zsq, psq, k1, k2)</code> La fonction <code>RedPar2ss.m</code> calcule \u00e0 partir des 4 param\u00e8tres r\u00e9duits une repr\u00e9sentation dans l'espace d'\u00e9tat.</p> <p>Il y a \u00e9galement des fichiers Python pour la simulation, mais ils sont moins \u00e9labor\u00e9s que les fichiers Matlab/Simulink cit\u00e9s ci-dessus.</p>"},{"location":"rpi5/","title":"Configuration du RPI5","text":"<p>Note</p> <p>A Compl\u00e9ter</p>"}]}